// This application lets the tester be the master of the session.
//  PlainTextNote - use for basic notetaking and copying xml etc

// References and Dependencies

using System;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Windows;
using System.Windows.Media.Effects;
using MessageBox = System.Windows.MessageBox;

#pragma warning disable 612,618
// ReSharper disable LocalizableElement

// Scope of the application.
// In this file we deal with the 'RTF Note Widget':
/*
 * +------------------------------------------------------------------------------------+
 * | +--------------------------------------------------------------------------------+ |
 * | | *ABC* aBc /123/                                                                | |
 * | +--------------------------------------------------------------------------------+ |
 * |                                                                       [ Save Note] |
 * +------------------------------------------------------------------------------------+
 */
namespace Rapid_Reporter.Forms
{
    // RTFNote controls the little text area to write enhanced notes for the session notes.
    public partial class PlainTextNote
    {
        public Boolean ForceClose = false;  // We keep the window open (although hidden) until the app is closed.
        int _currentPlainTextNote = 1;             // The number of the notes helps putting them in order, and finding them between the files (timestamp alone may confuse people).
        public SmWidget Sm;                 // Our interface to toggle the visual of the button in the main window is by direct referencing.
        public string WorkingDir = Directory.GetCurrentDirectory() + @"\";      // The directory to save files

        // Initialization, and setting focus to the richtextnote area
        public PlainTextNote()
        {
            InitializeComponent();
            // With the code below we control when to close the window or hide it.
            //  Didn't use a normal 'EventHandler' because we needed the Cancel option to close the window when appropriate.
            Closing += PlainTextNoteDialog_Close;
        }
        private void PlainTextNoteDialog_VisibilityChanged(object sender, DependencyPropertyChangedEventArgs e)
        {
            PlainTextNoteDialog_GotFocus();
        }
        private void PlainTextNoteDialog_GotFocus()
        {
            plainTextNote.Focus();
            plainTextNote.ScrollToEnd(); // Ready to enter new information
        }

        // When a note is cleared, there is no undo!
        private void clean_Click(object sender, RoutedEventArgs e)
        {
            plainTextNote.Clear();
            PlainTextNoteDialog_GotFocus(); // after we close the button, we're ready to input notes again
        }

        // When the note is 'saved', it get's saved into an PlainText file, and marked for being attached to a session note.
        private void save_Click(object sender, RoutedEventArgs e)
        {
            var textBoxContents = plainTextNote.Text;

            if (!string.IsNullOrWhiteSpace(textBoxContents)) 
            {
                // Name the note, save to file
                Sm.PlainTextNoteName = _currentPlainTextNote++.ToString(CultureInfo.InvariantCulture) + "_" + DateTime.Now.ToString("yyyyMMdd_HHmmss") + ".txt";

                try
                {
                    // Process is:
                    //  1. Save the file
                    //  2. Change the visual cue
                    //  3. Add an autogenerated line to the session CSV

                    var plainText = System.Net.WebUtility.HtmlEncode(textBoxContents);

                    // Saves the file
                    File.WriteAllText(WorkingDir + Sm.PlainTextNoteName, plainText);

                    // Set the visual effect to clue the tester there's a note attached
                    var effect = new BevelBitmapEffect {BevelWidth = 2, EdgeProfile = EdgeProfile.BulgedUp};
                    Sm.RTFNoteBtn.BitmapEffect = effect;

                    // Adds an 'autogenerated' line to the session CSV
                    Sm.SavePlainTextNote(Sm.PlainTextNoteName);
                    plainTextNote.Clear();
                }
                catch (Exception ex)
                {
                    MessageBox.Show(string.Format(
                        "Ouch! An error occured when trying to write the note into a file.\n" +
                        "The file name is: {0}\n\n" + "Possible causes:\n" +
                        " -- You don't have write permissions to the folder or file;\n" +
                        " -- The file is locked by another program (Excel? Explorer preview?);\n" +
                        " -- Windows preview pane is holding the file blocked for editing;\n" +
                        " -- (there may be other reasons).\n\n" + "Possible solutions:\n" +
                        " -- Set write permissions to the folder or file;\n" +
                        " -- Close another application that may be using the file;\n" +
                        " -- Select another file in explorer.\n\n" + "Exception details for investigation:\n{1}",
                        Sm.PlainTextNoteName, ex.Message));
                }
            }
            // We not really 'close' the window. Close function deals with whether hiding or closing it.
            Close();
        }

        // Always hide the window. Unless the app is being closed completely, then close too.
        //  When hiding the window, toggle the button status on the main Widget.
        private void PlainTextNoteDialog_Close(object sender, CancelEventArgs e)
        {

            Sm.IsPlainTextDiagOpen = false;

            // The only way I found to control on how to cancel the closing or not, was by using an external flag.
            if (ForceClose != true)
            {
                // Apparently, there is an exception in some machines when closing the app and/or PlainText
                //  we try to catch it here.
                //  Bug report: [94adb64c91]
                try
                {
                    typeof(Window).GetField("_isClosing", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(this, false);
                    e.Cancel = true; // Abort the close event
                    Hide(); // Hide is throwing an exception:
                    // "Cannot set visibility or call show, showdialog, close, or hide while window is closing"
                    //  Step 1 is supposed to overcome this exception. Hopefully.
                }
                catch
                {
                    // move to winform because mono
                    // use example formclosing from screeshot preview form
                }
            }
        }
    }
}
